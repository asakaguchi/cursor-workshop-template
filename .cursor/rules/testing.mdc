---
description: 
globs: tests/**/*.py
alwaysApply: false
---
# テスト開発ガイドライン（t-wada方式TDD）

## TDDの黄金律

**実装コードを書く前に、必ず失敗するテストを書く。**

t-wada氏が推奨するTDDの実践では、この原則を絶対に破ってはいけません。

## TDDのサイクル

### 1. Red（失敗するテストを書く）
- まず失敗するテストを1つだけ書く
- テストは具体的で、意図が明確なものにする
- 実行して失敗することを確認（エラーメッセージを読む）

### 2. Green（テストを通す）
- テストを通すための最小限のコードを書く
- 仮実装（Fake It）：まずは固定値を返す
- 三角測量（Triangulation）：複数のテストケースから一般化
- 明白な実装（Obvious Implementation）：自信がある場合のみ

### 3. Refactor（リファクタリング）
- すべてのテストが通っている状態を保つ（グリーンキープ）
- 重複を除去し、設計を改善
- 小さなステップで進める

## TDD実践の重要原則

### TODOリストの活用
- 実装すべきテストケースをTODOリストとして管理
- 1つずつ順番に実装（並行作業は避ける）
- 完了したらリストから削除

### テストの粒度
- **1つのテストメソッドには1つのアサーション**（アサーションルーレットの回避）
- 複数の検証が必要な場合は、テストを分割
- エッジケースは別のテストメソッドとして記述

### 実装の進め方
1. **仮実装から始める**：最初は固定値を返す
2. **三角測量で一般化**：複数のテストケースを追加
3. **段階的に実装を進化**：一度に完璧を目指さない

## テストの命名規則

テスト名は**仕様書として読める**ようにする：
- test_[対象]_[条件]_[期待結果]
- 日本語も可：test_商品作成_正常データ_201を返す
- 例: test_create_product_with_valid_data_returns_201
- 例: test_create_product_with_empty_name_returns_400

## テストの構造（AAA/Given-When-Then）

```python
def test_create_product_with_valid_data_returns_201():
    # Arrange (Given): テストの準備
    product_data = {"name": "テスト商品", "price": 1000}
    
    # Act (When): テスト対象の実行
    response = client.post("/items", json=product_data)
    
    # Assert (Then): 結果の検証
    assert response.status_code == 201
```

## インポート方法

```python
# context.pyを使用したインポート
from .context import product_api
```

## テストの実行

uvを使用してテストを実行します（ローカルPython環境）：

```bash
# 全テストを実行
uv run pytest tests/ -v

# 特定のテストファイルを実行
uv run pytest tests/test_basic.py -v

# カバレッジ付きで実行
uv run pytest tests/ --cov=src/product_api --cov-report=html

# 特定のテスト関数のみ実行
uv run pytest tests/test_basic.py::test_create_product -v
```

## pre-commitでの自動テスト実行

**重要**: 現在のプロジェクトでは、pre-commitフックでテストが自動実行されます：

```bash
# コミット時の自動フロー
git commit -m "..."
# 1. uv-lock（依存関係更新）
# 2. ruff-check --fix（コード修正）
# 3. ruff-format（フォーマット）
# 4. pytest-check（テスト実行）← **グリーンキープ保証**

# これにより、t-wada方式TDDの「グリーンキープ」原則が自動保証される
```

## テスト環境のセットアップ（ローカルPython環境）

```bash
# 開発用依存関係の同期（pyproject.tomlから）
uv sync

# 仮想環境を有効化
source .venv/bin/activate  # macOS/Linux
.venv\Scripts\activate     # Windows

# または個別に追加（必要に応じて）
uv add --dev pytest pytest-cov httpx anyio
```

## カバレッジ目標
- 最低80%のカバレッジを維持
- 重要なビジネスロジックは100%カバー

## TDD実践例：商品作成APIの開発

### ステップ1: 最初のテスト（Red）
```python
def test_create_product_returns_201():
    """商品作成が成功すると201を返す"""
    # このテストを書いた時点では、エンドポイントは存在しない
    response = client.post("/items", json={"name": "商品", "price": 100})
    assert response.status_code == 201  # 失敗する
```

### ステップ2: 仮実装（Green）
```python
@app.post("/items", status_code=201)
def create_item():
    return {}  # 最小限の実装
```

### ステップ3: 次のテスト（Red）
```python
def test_create_product_returns_created_product():
    """作成した商品の情報を返す"""
    response = client.post("/items", json={"name": "商品", "price": 100})
    data = response.json()
    assert data["name"] == "商品"  # 失敗する
    assert data["price"] == 100     # 失敗する
```

### ステップ4: 三角測量（Green）
```python
@app.post("/items", status_code=201)
def create_item(item: dict):
    return {"name": item["name"], "price": item["price"]}
```

### ステップ5: リファクタリング
```python
from pydantic import BaseModel

class Product(BaseModel):
    name: str
    price: float

@app.post("/items", status_code=201)
def create_item(item: Product) -> Product:
    return item
```

## 禁止事項

### TDDで絶対にやってはいけないこと
1. **テストなしで実装コードを書く**
2. **複数のテストを一度に書く**
3. **失敗を確認せずに次に進む**
4. **リファクタリング中にテストを変更する**
5. **1つのテストメソッドに複数のアサーションを書く**

### アンチパターン
```python
# ❌ 悪い例：アサーションルーレット
def test_create_product():
    response = client.post("/items", json={"name": "商品", "price": 100})
    assert response.status_code == 201
    assert response.json()["name"] == "商品"
    assert response.json()["price"] == 100
    assert "id" in response.json()
    assert "created_at" in response.json()

# ✅ 良い例：テストを分割
def test_create_product_returns_201():
    response = client.post("/items", json={"name": "商品", "price": 100})
    assert response.status_code == 201

def test_create_product_returns_name():
    response = client.post("/items", json={"name": "商品", "price": 100})
    assert response.json()["name"] == "商品"

def test_create_product_returns_price():
    response = client.post("/items", json={"name": "商品", "price": 100})
    assert response.json()["price"] == 100
```